/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference types="@adonisjs/lucid" />
/// <reference types="@adonisjs/lucid" />
import { LucidModel } from '@ioc:Adonis/Lucid/Orm';
import { DatabaseContract } from '@ioc:Adonis/Lucid/Database';
import { SlugifyConfig, SlugifyStrategyContract } from '@ioc:Adonis/Addons/LucidSlugify';
import { SimpleStrategy } from './Simple';
/**
 * Uses a counter variable to make slugs unique
 */
export declare class DbIncrementStrategy extends SimpleStrategy implements SlugifyStrategyContract {
    private db;
    private counterName;
    constructor(db: DatabaseContract, config: SlugifyConfig);
    /**
     * Makes the slug by inspecting multiple similar rows in JavaScript
     */
    private makeSlugFromMultipleRows;
    /**
     * Makes the slug unique by using the runtime slug counter field
     */
    private makeSlugFromCounter;
    /**
     * Returns the slug for sqlite
     */
    private getSlugForSqlite;
    /**
     * Returns the slug for MYSQL < 8.0
     */
    private getSlugForOldMysql;
    /**
     * Returns the slug for MYSQL >= 8.0
     */
    private getSlugForMysql;
    /**
     * Returns the slug for mssql. With MSSQL it maybe is possible to use the
     * T-SQL with Patindex to narrow down the search query. But for now
     * I want to save time and not concern myself much with learning
     * T-SQL.
     *
     * If you use MSSQL and concerned with performance. Please take out time and
     * help improve the MSSQL query
     */
    private getSlugForMssql;
    /**
     * Makes slug for PostgreSQL and redshift both. Redshift is not tested and
     * assumed to be compatible with PG.
     */
    private getSlugForPg;
    /**
     * Makes slug for Oracle. Oracle is not tested
     */
    private getSlugForOracle;
    /**
     * Converts an existing slug to a unique slug by inspecting the database
     */
    makeSlugUnique(model: LucidModel, field: string, slug: string): Promise<string>;
}
